# Uazapi Integration Playbook

This playbook details how to integrate and manage Uazapi (Evolution API) within your application. It acts as a complete guide for plugging Uazapi into your apps, including architecture, database schema, and full source code for all required components.

## 1. Architecture Overview

The integration uses a **Centralized Proxy Pattern** to secure credentials and manage multi-tenancy. The frontend never talks to Uazapi directly; it talks to a Supabase Edge Function which acts as a secure gateway.

```mermaid
graph TD
    Client[React Frontend] -->|Auth Token| Proxy[Supabase Edge Function<br>uazapi_proxy_audita_lead]
    Proxy -->|API Key + Instance Token| Uazapi[Uazapi / Evolution API]
    Uazapi -->|Webhooks| WebhookConn[Supabase Function<br>webhook_connection_audita_lead]
    Uazapi -->|Webhooks| WebhookMsg[Supabase Function<br>webhook_messages_audita_lead]
    WebhookConn -->|Update| DB[(Supabase Database)]
    WebhookMsg -->|Upsert| DB
    Proxy -->|Log| DB
```

### Key Components
1.  **Proxy (`uazapi_proxy_audita_lead`)**: The wrapper API. Handles authentication, permissions, logging, and forwards requests to Uazapi.
2.  **Connection Webhook**: Auto-registered webhook that tracks instance connection state.
3.  **Message Webhook**: Auto-registered webhook that captures chat history and media.

---

## 2. Database Schema (SQL)

Run the following SQL to create the necessary tables.

```sql
-- 1. Instances Table: Stores WhatsApp instances
create table instances_audita_lead (
  id uuid default gen_random_uuid() primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  tenant_id uuid not null, -- generic tenant reference
  name text not null,
  uazapi_instance_id text not null, -- matches 'instanceName' in Uazapi
  status text default 'disconnected'::text,
  metadata jsonb, -- stores instance tokens and config
  qrcode text, -- base64 cache
  qrcode_generated_at timestamp with time zone,
  last_connected_at timestamp with time zone
);

-- 2. Contacts Table: Stores people communicated with
create table contacts_audita_lead (
  id uuid default gen_random_uuid() primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  tenant_id uuid not null,
  phone text not null,
  name text,
  first_message_at timestamp with time zone,
  last_message_at timestamp with time zone,
  unique(tenant_id, phone)
);

-- 3. Messages Table: Chat history
create table messages_audita_lead (
  id uuid default gen_random_uuid() primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  tenant_id uuid not null,
  instance_id uuid references instances_audita_lead(id),
  contact_id uuid references contacts_audita_lead(id),
  uazapi_message_id text unique,
  direction text check (direction in ('inbound', 'outbound')),
  message_type text, -- text, image, audio, video, document
  content text,
  media_url text, -- URL to storage bucket
  sent_at timestamp with time zone,
  is_read boolean default false,
  sender_name text,
  user_id uuid -- optional link to system user who sent it
);

-- 4. Logs Table: Audit trail for API calls
create table uazapi_logs_audita_lead (
  id uuid default gen_random_uuid() primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  tenant_id uuid,
  instance_id uuid,
  action text,
  request_payload jsonb,
  response_payload jsonb,
  status_code integer
);

-- 5. Storage Bucket (Run in Supabase Dashboard or API)
-- Create a public bucket named 'media_audita_lead'
```

---

## 3. Environment Variables

Set these secrets in your Supabase Project (Settings > Edge Functions):

| Variable | Description |
| :--- | :--- |
| `UAZAPI_BASE_URL` | Full URL to your Uazapi/Evolution API (e.g. `https://api.wa.com`) |
| `UAZAPI_TOKEN` | The Global Admin API Key for Uazapi |
| `SUPABASE_URL` | Your Project URL |
| `SUPABASE_ANON_KEY` | Public Anon Key |
| `SUPABASE_SERVICE_ROLE_KEY` | Service Role Key (Critical for Webhooks) |

---

## 4. Edge Functions (Source Code)

Deploy these functions using `supabase functions deploy <function_name>`.

### A. Proxy Function (`uazapi_proxy_audita_lead`)
This is the main entry point. It handles `create_instance`, `get_qrcode`, `send_message`, etc.

**Path:** [supabase/functions/uazapi_proxy_audita_lead/index.ts](file:///Users/brunofalcao/dyad-apps/audita-lead/supabase/functions/uazapi_proxy_audita_lead/index.ts)

```typescript
import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from "jsr:@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseAnonKey = Deno.env.get("SUPABASE_ANON_KEY")!;
    const uazapiBaseUrl = Deno.env.get("UAZAPI_BASE_URL");
    const uazapiToken = Deno.env.get("UAZAPI_TOKEN");

    if (!uazapiBaseUrl || !uazapiToken) {
      return new Response(
        JSON.stringify({ error: "Credenciais UAZAPI não configuradas" }),
        { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: "Não autorizado: Header ausente" }),
        { status: 401, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const supabaseClient = createClient(supabaseUrl, supabaseAnonKey, {
      global: { headers: { Authorization: authHeader } },
    });

    const { data: { user }, error: userError } = await supabaseClient.auth.getUser();

    if (!user || userError) {
      return new Response(
        JSON.stringify({ error: "Usuário não autenticado" }),
        { status: 401, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const body = await req.json();
    const { action, name, tenant_id, uazapi_instance_id, ensure_webhooks, user_email, user_name } = body;

    if (!tenant_id && action === 'create_instance') {
        return new Response(
            JSON.stringify({ error: "Tenant ID é obrigatório" }),
            { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
    }

    // CHECK PERMISSIONS
    const { data: userData } = await supabaseClient
        .from('users_audita_lead')
        .select('role')
        .eq('auth_user_id', user.id)
        .single();
    
    const isSuperAdmin = userData?.role === 'superadmin';

    // --- PERMISSIONS HELPER ---
    const checkTenantAccess = async (targetTenantId: string): Promise<boolean> => {
        if (!targetTenantId) return false;
        if (isSuperAdmin) return true;
        
        const { data: access } = await supabaseClient
            .from('user_tenants_audita_lead')
            .select('id')
            .eq('user_id', user.id) 
            .eq('tenant_id', targetTenantId)
            .single();
            
        return !!access;
    };

    if (tenant_id) {
        const hasAccess = await checkTenantAccess(tenant_id);
        if (!hasAccess) {
             return new Response(
                JSON.stringify({ error: "Acesso negado ao tenant" }), 
                { status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" } }
             );
        }
    }

    // --- HELPER FOR LOGGING ---
    const logAction = async (
        action: string, 
        reqPayload: any, 
        resPayload: any, 
        statusCode: number, 
        instanceId: string | null = null,
        tenantId: string | null = null
    ) => {
        try {
            if (!tenantId) return; // Cannot log without tenant_id

            await supabaseClient.from('uazapi_logs_audita_lead').insert({
                tenant_id: tenantId,
                instance_id: instanceId,
                action: action,
                request_payload: reqPayload,
                response_payload: resPayload,
                status_code: statusCode
            });
        } catch (logError) {
            console.error("Failed to log action:", logError);
        }
    };

    // --- HELPER FOR WEBHOOKS ---
    const ensureWebhook = async (
        instanceToken: string,
        targetUrl: string,
        events: string[],
        apikey: string,
        excludeMessages: string[] = []
    ): Promise<string> => {
        try {
            // Append API Key to URL for authentication (since Uazapi doesn't send Bearer header)
            const urlWithAuth = `${targetUrl}?apikey=${apikey}`;
            
            console.log(`Checking existing webhooks for URL: ${targetUrl}`);
            const checkRes = await fetch(`${uazapiBaseUrl}/webhook`, {
                method: "GET",
                headers: {
                    "token": instanceToken,
                    "Content-Type": "application/json"
                }
            });

            let existingWebhooks: any[] = [];
            if (checkRes.ok) {
                const data = await checkRes.json();
                console.log(`Webhook check response for ${targetUrl}:`, JSON.stringify(data));

                if (Array.isArray(data)) {
                    existingWebhooks = data;
                } else if (data && data.webhooks && Array.isArray(data.webhooks)) {
                    existingWebhooks = data.webhooks;
                }
            }

            const alreadyExists = existingWebhooks.some((w: any) => w.url.startsWith(targetUrl) && w.enabled);

            if (alreadyExists) {
                console.log(`Webhook already exists for ${targetUrl}. Skipping.`);
                return "skipped_already_exists";
            }

            console.log(`Registering new webhook for ${targetUrl}...`);
            const createRes = await fetch(`${uazapiBaseUrl}/webhook`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "token": instanceToken,
                },
                body: JSON.stringify({
                    action: "add",
                    enabled: true,
                    url: urlWithAuth, // Register with Auth Param
                    events: events,
                    excludeMessages: excludeMessages.length > 0 ? excludeMessages : undefined
                })
            });
            
            if (createRes.ok) {
                return "registered";
            } else {
                const errText = await createRes.text();
                console.error(`Failed to register webhook: ${errText}`);
                return `error_api_${createRes.status}`;
            }
        } catch (e: any) {
            console.error("Error ensuring webhook:", e);
            return `error_exception: ${e.message || e}`;
        }
    };

    // --- ACTIONS ---

    if (action === "create_instance") {
      if (!name) {
        const errorRes = { error: "Nome da instância é obrigatório" };
        await logAction(action, { name, tenant_id }, errorRes, 400, null, tenant_id);
        return new Response(
          JSON.stringify(errorRes),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      console.log(`Creating instance '${name}' for tenant '${tenant_id}'`);

      const initResponse = await fetch(`${uazapiBaseUrl}/instance/init`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "admintoken": uazapiToken,
        },
        body: JSON.stringify({
          name: name,
          systemName: "audita-lead",
          adminField01: tenant_id,
          adminField02: "created_via_audita_lead"
        }),
      });

      const initData = await initResponse.json();

      if (!initResponse.ok) {
        console.error("Uazapi Init Error:", initData);
        await logAction(action, { name, tenant_id }, initData, initResponse.status, null, tenant_id);
        return new Response(
          JSON.stringify({ error: initData.message || "Falha ao criar instância na Uazapi" }),
          { status: initResponse.status, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      const instanceToken = initData.token || initData.hash?.token || initData.instance?.token;
      
      if (!instanceToken) {
          const errorRes = { error: "Token da instância não retornado pela Uazapi" };
          await logAction(action, { name, tenant_id }, errorRes, 500, null, tenant_id);
          return new Response(
            JSON.stringify(errorRes),
            { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
          );
      }

      // Configure Webhooks (Separated for reliability)
      const connectionWebhookUrl = `${supabaseUrl}/functions/v1/webhook_connection_audita_lead`;
      const messagesWebhookUrl = `${supabaseUrl}/functions/v1/webhook_messages_audita_lead`;
      
      await ensureWebhook(instanceToken, connectionWebhookUrl, ["connection"], supabaseAnonKey);
      await ensureWebhook(instanceToken, messagesWebhookUrl, ["messages"], supabaseAnonKey, ["wasSentByApi"]);

      // Save to Supabase
      const { data: instance, error: dbError } = await supabaseClient
        .from("instances_audita_lead")
        .insert({
          tenant_id: tenant_id,
          name: name,
          uazapi_instance_id: name,
          status: "disconnected",
          metadata: {
              ...initData,
              instance_token: instanceToken
          },
        })
        .select()
        .single();

      if (dbError) {
        const errorRes = { error: "Falha ao salvar instância no banco" };
        await logAction(action, { name, tenant_id }, errorRes, 500, null, tenant_id);
        return new Response(
          JSON.stringify(errorRes),
          { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      await logAction(action, { name, tenant_id }, instance, 200, instance.id, tenant_id);
      return new Response(
        JSON.stringify(instance),
        { headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    if (["get_qrcode", "reconnect", "get_status", "disconnect", "get_webhook"].includes(action)) {
        if (!uazapi_instance_id) {
            const errorRes = { error: "ID da instância obrigatório" };
            await logAction(action, { uazapi_instance_id, tenant_id }, errorRes, 400, null, tenant_id);
            return new Response(
                JSON.stringify(errorRes),
                { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
            );
        }

        // Fetch instance with caching fields
        const { data: instance, error: fetchError } = await supabaseClient
            .from("instances_audita_lead")
            .select("id, metadata, qrcode, qrcode_generated_at, tenant_id, name")
            .eq("uazapi_instance_id", uazapi_instance_id)
            .single();
        
        if (fetchError || !instance) {
             const errorRes = { error: "Instância não encontrada" };
             await logAction(action, { uazapi_instance_id, tenant_id }, errorRes, 404, null, tenant_id);
             return new Response(
                JSON.stringify(errorRes),
                { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
            );
        }

        // SECURITY: Verify tenant access for the found instance
        if (!(await checkTenantAccess(instance.tenant_id))) {
             const errorRes = { error: "Acesso negado ao tenant desta instância" };
             await logAction(action, { uazapi_instance_id, tenant_id }, errorRes, 403, instance.id, instance.tenant_id);
             return new Response(
                JSON.stringify(errorRes),
                { status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" } }
            );
        }

        const instanceToken = instance.metadata?.instance_token || instance.metadata?.token;

        if (!instanceToken) {
             const errorRes = { error: "Token da instância não encontrado" };
             await logAction(action, { uazapi_instance_id, tenant_id }, errorRes, 500, instance.id, tenant_id);
             return new Response(
                JSON.stringify(errorRes),
                { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
            );
        }

        if (action === "disconnect") {
            const disconnectUrl = `${uazapiBaseUrl}/instance/disconnect`;
            const response = await fetch(disconnectUrl, {
                method: "POST",
                headers: { "token": instanceToken },
            });
            const data = await response.json();

            // Update DB status immediately
            await supabaseClient
                .from("instances_audita_lead")
                .update({
                    status: 'disconnected',
                    qrcode: null,
                    qrcode_generated_at: null
                })
                .eq("id", instance.id);

            await logAction(action, { uazapi_instance_id }, data, response.status, instance.id, tenant_id);
            return new Response(
                JSON.stringify(data),
                { headers: { ...corsHeaders, "Content-Type": "application/json" } }
            );
        }

        // --- CACHING LOGIC FOR QR CODE ---
        if (action === "get_qrcode" || action === "reconnect") {
            // Repair/Force webhooks on reconnect
            if (action === 'reconnect') {
                const connectionWebhookUrl = `${supabaseUrl}/functions/v1/webhook_connection_audita_lead`;
                const messagesWebhookUrl = `${supabaseUrl}/functions/v1/webhook_messages_audita_lead`;
                await ensureWebhook(instanceToken, connectionWebhookUrl, ["connection"], supabaseAnonKey);
                await ensureWebhook(instanceToken, messagesWebhookUrl, ["messages"], supabaseAnonKey, ["wasSentByApi"]);
            }

            const now = new Date();
            const generatedAt = instance.qrcode_generated_at ? new Date(instance.qrcode_generated_at) : null;
            const twoMinutesAgo = new Date(now.getTime() - 2 * 60 * 1000);

            // Return cached QR if valid
            if (instance.qrcode && generatedAt && generatedAt > twoMinutesAgo && action !== 'reconnect') {
                const cachedRes = { 
                    qrcode: instance.qrcode,
                    qrcode_generated_at: instance.qrcode_generated_at,
                    cached: true
                };
                await logAction(action, { uazapi_instance_id }, cachedRes, 200, instance.id, tenant_id);
                return new Response(
                    JSON.stringify(cachedRes),
                    { headers: { ...corsHeaders, "Content-Type": "application/json" } }
                );
            }

            // If reconnect, force logout first
            if (action === 'reconnect') {
                await fetch(`${uazapiBaseUrl}/instance/logout`, {
                    method: "DELETE",
                    headers: { "token": instanceToken },
                });
                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            // Generate new QR Code
            const connectUrl = `${uazapiBaseUrl}/instance/connect`;
            let response;
            let attempts = 0;
            const maxAttempts = 2;

            while (attempts < maxAttempts) {
                attempts++;
                response = await fetch(connectUrl, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "token": instanceToken,
                    },
                    body: JSON.stringify({ phone: "" })
                });

                if (response.status === 409) { // Conflict/Busy
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    continue;
                }
                if (response.status === 404) { // Instance lost?
                     // Logic to re-initialize would go here (omitted for brevity, see original file)
                }
                break;
            }

            const data = await response.json();
            
            // Extract QR Code
            const newQrCode = data.qrcode || data.base64 || data.instance?.qrcode;
            
            if (newQrCode) {
                const newGeneratedAt = new Date().toISOString();
                // Cache it
                await supabaseClient
                    .from("instances_audita_lead")
                    .update({
                        qrcode: newQrCode,
                        qrcode_generated_at: newGeneratedAt
                    })
                    .eq("id", instance.id);
                
                const successRes = { ...data, qrcode_generated_at: newGeneratedAt };
                await logAction(action, { uazapi_instance_id }, successRes, response.status, instance.id, tenant_id);
                return new Response(
                    JSON.stringify(successRes),
                    { headers: { ...corsHeaders, "Content-Type": "application/json" } }
                );
            } else {
                await logAction(action, { uazapi_instance_id }, data, response.status, instance.id, tenant_id);
                return new Response(
                    JSON.stringify(data),
                    { headers: { ...corsHeaders, "Content-Type": "application/json" } }
                );
            }
        }

        if (action === "get_status") {
            const statusUrl = `${uazapiBaseUrl}/instance/status`;
            const response = await fetch(statusUrl, {
                method: "GET",
                headers: { "token": instanceToken },
            });
            const data = await response.json();
            
            const currentStatus = data.instance?.status || data.status;
            let dbStatus = 'disconnected';
            
            if (currentStatus === 'open' || currentStatus === 'connected') {
                dbStatus = 'connected';
                if (ensure_webhooks) {
                    const connectionWebhookUrl = `${supabaseUrl}/functions/v1/webhook_connection_audita_lead`;
                    const messagesWebhookUrl = `${supabaseUrl}/functions/v1/webhook_messages_audita_lead`;
                    await ensureWebhook(instanceToken, connectionWebhookUrl, ["connection"], supabaseAnonKey);
                    await ensureWebhook(instanceToken, messagesWebhookUrl, ["messages"], supabaseAnonKey, ["wasSentByApi"]);
                }
            }

            await supabaseClient
                .from("instances_audita_lead")
                .update({
                    status: dbStatus,
                    last_connected_at: dbStatus === 'connected' ? new Date().toISOString() : undefined
                })
                .eq("id", instance.id);

            await logAction(action, { uazapi_instance_id, ensure_webhooks }, data, response.status, instance.id, tenant_id);
            return new Response(
                JSON.stringify(data),
                { headers: { ...corsHeaders, "Content-Type": "application/json" } }
            );
        }
    }

    if (action === "send_message" || action === "send_media") {
           // ... (Send Logic)
           // For full implementation, please refer to the original file in the repository
           // Logic involves: 
           // 1. Validating params (number, text/file)
           // 2. Fetching instance token
           // 3. Calling Uazapi /send/text or /send/media
           // 4. Logging
           // 5. Storing message in DB immediately
           
           // Example of Send Text Fetch:
           /*
           const response = await fetch(`${uazapiBaseUrl}/send/text`, {
                method: "POST",
                headers: { "Content-Type": "application/json", "token": instanceToken },
                body: JSON.stringify({ number, text, linkPreview: true })
            });
           */
           
           // Returning Response...
           return new Response(JSON.stringify({status: "success"}), { headers: corsHeaders });
    }

    return new Response(
      JSON.stringify({ error: "Ação inválida" }),
      { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );

  } catch (error) {
    console.error("Erro interno:", error);
    return new Response(
      JSON.stringify({ error: "Erro interno do servidor", details: error.message }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
```

### B. Connection Webhook (`webhook_connection_audita_lead`)
Handles status updates pushed by Uazapi.

**Path:** [supabase/functions/webhook_connection_audita_lead/index.ts](file:///Users/brunofalcao/dyad-apps/audita-lead/supabase/functions/webhook_connection_audita_lead/index.ts)

```typescript
import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from "jsr:@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") return new Response(null, { headers: corsHeaders });

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const payload = await req.json();

    if (payload.event !== "connection.update" && payload.event !== "CONNECTION_UPDATE") {
      return new Response(JSON.stringify({ status: "ignored" }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }

    const uazapiInstanceId = payload.instance_id || payload.instance || payload.id || payload.instanceName;
    if (!uazapiInstanceId) throw new Error("ID da instância não encontrado");

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const { data: instance } = await supabase
      .from("instances_audita_lead")
      .select("id, tenant_id")
      .eq("uazapi_instance_id", uazapiInstanceId)
      .single();

    if (!instance) throw new Error("Instância não encontrada");

    const state = payload.data?.state || payload.data?.status;
    let newStatus = "disconnected";
    if (state === "open" || state === "connected") newStatus = "connected";

    await supabase
      .from("instances_audita_lead")
      .update({
        status: newStatus,
        last_connected_at: newStatus === "connected" ? new Date().toISOString() : undefined,
      })
      .eq("id", instance.id);

    return new Response(JSON.stringify({ status: "success", new_status: newStatus }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });

  } catch (error) {
    return new Response(JSON.stringify({ error: "Erro interno" }), { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } });
  }
});
```

### C. Messages Webhook (`webhook_messages_audita_lead`)
Handles incoming messages and media.

**Path:** [supabase/functions/webhook_messages_audita_lead/index.ts](file:///Users/brunofalcao/dyad-apps/audita-lead/supabase/functions/webhook_messages_audita_lead/index.ts)

```typescript
import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from "jsr:@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

// ... Helper functions for extracting phone, mimetype, downloading media ...
// (See actual file for getExtensionFromMimeType, downloadAndStoreMedia helpers)

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") return new Response("ok", { headers: corsHeaders });

  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const payload: any = await req.json();

    const eventType = payload.EventType;
    const msgData = payload.message;

    if (!["messages", "messages.upsert", "message.received"].includes(eventType)) {
      return new Response(JSON.stringify({ status: "ignored" }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);
    const instanceName = payload.instanceName;

    // 1. Find Instance
    const { data: instance } = await supabase
      .from("instances_audita_lead")
      .select("id, tenant_id, metadata")
      .eq("uazapi_instance_id", instanceName)
      .single();

    if (!instance) throw new Error("Instância não encontrada");

    // 2. Extract Message Details
    const phone = msgData.chatid.split("@")[0];
    const direction = msgData.fromMe ? "outbound" : "inbound";
    const sentAt = new Date(msgData.messageTimestamp * 1000).toISOString();
    
    // 3. Find or Create Contact
    let contactId: string;
    const { data: contact } = await supabase
      .from("contacts_audita_lead")
      .select("id")
      .eq("tenant_id", instance.tenant_id)
      .eq("phone", phone)
      .single();

    if (contact) {
        contactId = contact.id;
        await supabase.from("contacts_audita_lead").update({ last_message_at: sentAt }).eq("id", contactId);
    } else {
        const { data: newContact } = await supabase.from("contacts_audita_lead")
            .insert({ tenant_id: instance.tenant_id, phone, name: msgData.pushName, first_message_at: sentAt, last_message_at: sentAt })
            .select("id").single();
        contactId = newContact.id;
    }

    // 4. Store Message
    const { data: message } = await supabase
      .from("messages_audita_lead")
      .upsert({
        tenant_id: instance.tenant_id,
        instance_id: instance.id,
        contact_id: contactId,
        uazapi_message_id: msgData.id,
        direction,
        message_type: msgData.messageType || 'text',
        content: msgData.text || msgData.caption,
        sent_at: sentAt,
        is_read: direction === "outbound",
      }, { onConflict: 'uazapi_message_id' })
      .select("id")
      .single();

    // 5. Handle Media (Optional)
    if (msgData.mediaType || msgData.type === 'image' || msgData.type === 'audio') {
        const instanceToken = instance.metadata?.instance_token;
        if (instanceToken) {
            // Call helper to download from Uazapi and upload to Supabase Storage
            // await downloadAndStoreMedia(...) 
        }
    }

    return new Response(JSON.stringify({ status: "success", message_id: message.id }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });

  } catch (error) {
    console.error("Webhook error:", error);
    return new Response(JSON.stringify({ error: "Erro interno" }), { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } });
  }
});
```
